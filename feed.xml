<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>xitlog</title>
 <link href="https://radarroark.github.io/xit"/>
 <updated>2025-03-21T00:00:00Z</updated>
 <author>
   <name>radar roark</name>
 </author>
 <id>https://radarroark.github.io/xit</id>

 <entry>
  <title>devlog - faster diffing/cloning, lazy patches, and more</title>
  <link href="https://radarroark.github.io/xit/devlog-faster-diff-and-clone.html" title="devlog-faster-diff-and-clone"/>
  <id>urn:uuid:18c76e83-8ce1-464c-a7ab-6ee6ce4154a9</id>
  <updated>2025-03-21T00:00:00Z</updated>
  <content type="html" xml:lang="en"><![CDATA[
  <p>Rejoice! xit is no longer quite as dog slow as it was before. In particular, writing objects (at the end of a clone or fetch) and generating patches are much faster now. After some investigation, it became clear that the problem was the same in both cases: xit was constantly reading small pieces of files from the disk.</p>
  <p>To solve this, I <a href="https://github.com/radarroark/xit/commit/68b0d14f96390d4360b2b821ab8b55a015368e19">first</a> made it read text files fully into memory for diffing. I <a href="https://github.com/radarroark/xit/commit/ba86653fcc78b79c95c67613c3fd23ee35749f19">then</a> updated the pack object reader to load objects from pack files entirely into memory (if they are below a certain file size). After these two changes, generating patches and cloning/fetching are much faster.</p>
  <p>The UI got some love as well. I noticed that I neglected to show conflicts in the status TUI, and that has been <a href="https://github.com/radarroark/xit/commit/6ecbeae2fa64fc8052d7bbafc7466653efeff640">fixed</a>. A while later, I began <a href="https://github.com/radarroark/xit/commit/42eaf5a69f34087dc31d3c518d754738a35a3458">embedding</a> TUIs into my unit tests. Yes, I mean literally making assertions that embed the TUI in a big string. It's glorious...let's see you do that, GUI / web developers.</p>
  <p>I also made some critical networking fixes recently. I <a href="https://github.com/radarroark/xit/commit/8a2da06faf00daf232f7420b9d032d9cfdaa5bf3">revamped</a> and <a href="https://github.com/radarroark/xit/commit/f312357078c5184ab0068d6ff5d07f405af212dd">fixed</a> the http code, because it was quite badly broken for more complex fetches. Hopefully it will now be as reliable as the ssh code, which is inherently easier to get right due to its simplicity (the ssh client does most of the work, after all).</p>
  <p>After the above-mentioned performance fixes, I felt comfortable <a href="https://github.com/radarroark/xit/commit/ae08487e7dd0f340f64613e4eac8a8649105a367">re-enabling</a> compression on text chunks. Previously, I had disabled it because patch generation was so slow, I didn't want to slow it down more with compression. It is now enabled, though xit repos will normally still take up much more space than git repos; there are plenty more optimizations coming.</p>
  <p>Lastly, I've received a slew of great PRs from my first contributor, and <a href="https://github.com/radarroark/xit/commit/927def28698d516ba720c36cd3a9b4bba03b4a97">this</a> one is worth noting. When you enable patch-based merging with `xit patch on`, it now generates the necessary patches at merge time rather than right away. If you actually want to generate them all in advance, you can do `xit patch all`. Generating them lazily is a great idea because it allows you to delay the work until it's needed, and only do the work for commits that are involved in the merge.</p>
  ]]></content>
 </entry>

 <entry>
  <title>the timelessness of TUIs</title>
  <link href="https://radarroark.github.io/xit/the-timelessness-of-tuis.html" title="the-timelessness-of-tuis"/>
  <id>urn:uuid:5b07b6b8-edc0-4446-8bc2-6e55cdb8f52d</id>
  <updated>2025-03-16T00:00:00Z</updated>
  <content type="html" xml:lang="en"><![CDATA[
  <p>The lowest common denominator of all UIs is text. In a way, TUIs (text user interfaces) are the only truly cross-platform UI. They can be rendered anywhere, including *inside* of other interfaces. They're nearly guaranteed to work on any hardware we invent in the future.</p>
  <p>Compared to GUIs, however, TUIs are much lower resolution. You are limited to monospaced unicode characters. This feels like a negative, but it isn't. TUIs force you to distill your interface down to its most basic elements. Anything nonessential must go.</p>
  <p>TUIs are inoculated from the excesses of modern software design. You don't get to have drop shadows, transparency, or scrolljacking. You get a limited palette of characters and colors, leaving the raw design of your interface to stand or fall on its own.</p>
  <p>Limitations are a powerful catalyst for creativity. Curious people see limitations as an invitation to overcome them. Give a curious child a TI-83 and he will give you Space Invaders. Give him Minecraft and he will give you Roman aqueducts.</p>
  <p>Orson Welles put it succinctly: "The enemy of art is the absence of limitations." There is no better way to snuff creativity out of a man than to give him endless resources and no deadline. Often, your best work comes when you have the strictest constraints...like having 1980s computer hardware that could display a whopping 16 different colors:</p>
  <div data-node="dragon">Not visible in the RSS feed, sowwy.</div>
  I'm making <a href="https://github.com/radarroark/xit">xit</a>, a version control system with a built-in TUI. It's still in its infancy but lately I've been working on the status view. If I were doing this in a GUI, I'd have spent a long time trying to decide how it should look, what controls to use, and so on. With a TUI, the decision paralysis goes away and you just do the dumb, simple thing:
  <code> 
     ╔══════╗                                                                   
 log ║status║                                                                   
     ╚══════╝                                                                   
┌─────────┐                                                                     
│added (1)│ not added (0)  not tracked (0)                                      
└─────────┘                                                                     
   ┌─────┐          ┌──────────────────────────────────────────────────────────┐
 ± │f.txt│          │                                                          │
   └─────┘          │ diff --git a/f.txt b/f.txt                               │
                    │ index 98d5083..ae42890 100644                            │
                    │ --- a/f.txt                                              │
                    │ +++ b/f.txt                                              │
                    │                                                          │
                    │                                                          │
                    │                                                          │
                    │ @@ -1,3 +1,3 @@                                          │
                    │   a                                                      │
                    │ - x                                                      │
                    │ + y                                                      │
                    │   c                                                      │
                    │                                                          │
                    │                                                          │
                    └──────────────────────────────────────────────────────────┘
  </code>
  If there's a merge conflict, it looks like this:
  <code> 
     ╔══════╗                                                                    
 log ║status║                                                                    
     ╚══════╝                                                                    
           ┌─────────────┐                                                       
 added (0) │not added (1)│ not tracked (0)                                       
           └─────────────┘                                                       
   ┌─────┐          ┌───────────────────────────────────────────────────────────┐
 ≠ │f.txt│          │                                                           │
   └─────┘          │ diff --git a/f.txt b/f.txt                                │
                    │ index 98d5083..c3736c3 100644                             │
                    │ --- a/f.txt                                               │
                    │ +++ b/f.txt                                               │
                    │                                                           │
                    │                                                           │
                    │                                                           │
                    │ @@ -1,3 +1,9 @@                                           │
                    │   a                                                       │
                    │ + ⟨⟨⟨⟨⟨⟨⟨ target (master)                                 │
                    │   x                                                       │
                    │ + ||||||| base (31791fdb2aea4e32bde323475a03cfec7ad51bf4) │
                    │ + b                                                       │
                    │ + =======                                                 │
                    │ + y                                                       │
                    │ + ⟩⟩⟩⟩⟩⟩⟩ source (foo)                                    │
                    │   c                                                       │
                    │                                                           │
                    │                                                           │
                    └───────────────────────────────────────────────────────────┘
  </code>
  <p>With TUIs, you have permission to just do the plain, boring thing, which is likely the thing that will keep working well many years from now when UI design trends change.</p>
  <p>Since TUIs are just text, you can embed them direcly in your unit tests like <a href="https://github.com/radarroark/xit/blob/ba86653fcc78b79c95c67613c3fd23ee35749f19/src/test/repo.zig#L1351">this</a>! Your entire UI can be tested from within the rest of your tests. The tests also become very easy to skim for the reader because they provide such an immediate, visual representation of what state you're in.</p>
  <p>For developer tools, TUIs are a no-brainer. It blows my mind that tools are still shipping with an entire web browser inside them just to render an interface for people who are already very comfortable with the terminal. With a TUI, I can use your tool over SSH, and I have total control over the colors and fonts it uses to render.</p>
  <p>TUIs are not a relic of the past. Every GUI framework you are using today will eventually become obsolete, while the simplicity and timelessness of TUIs will remain. GUIs get remembered, but <a href="https://www.youtube.com/shorts/U_pqRP-4hUc">TUIs never die</a>.</p>
  ]]></content>
</entry>

 <entry>
  <title>devlog - optional patches, force push, symlinks and more</title>
  <link href="https://radarroark.github.io/xit/devlog-optional-patches.html" title="devlog-optional-patches"/>
  <id>urn:uuid:7aa7555a-0163-4590-b0f6-4da325dbd692</id>
  <updated>2025-03-13T00:00:00Z</updated>
  <content type="html" xml:lang="en"><![CDATA[
  <p>I got my first couple bug reports...mama, we made it! In <a href="https://github.com/radarroark/xit/issues/2">#2</a> I forgot that in <a href="https://github.com/radarroark/xitdb">xitdb</a>, data made in a transaction is temporarily mutable (an important perf optimization). It's fun forgetting how my own database works. In <a href="https://github.com/radarroark/xit/issues/4">#4</a> I forgot that when you merge, the base commit might not actually contain the conflicting file. Oops.</p>
  <p>Shortly after that, I made patch-based merging <a href="https://github.com/radarroark/xit/commit/cfd04126c30a76c93d60b2c94e976fec81cae36e">optional</a>. It no longer generates patches during the clone, so cloning repos with large histories won't outlast the heat death of the universe. It still takes more time than git, because it is decompressing and chunking each object...I'm working on making it faster.</p>
  <p>The next morning I woke up feeling particularly masochistic, so I decided to work on the pack file code. I noticed that some fetches were failing because the pack file from the server contained a <a href="https://git-scm.com/docs/pack-format">REF_DELTA</a> object, which is an deltified object whose base object is not in the pack and is expected to already be in the object store. I <a href="https://github.com/radarroark/xit/commit/940452a07f9dc7f299d200a3f5f6de29fa3b3738">fixed</a> the pack object reader to read these objects correctly, and then told my therapist all about it later that day.</p>
  <p>After recovering from that eldritch horror I implemented <a href="https://github.com/radarroark/xit/commit/cc3467ca99118867462314b4ee940f99ac6bac8c">--abort</a> for merge and cherry-pick. This would normally be easy because it's essentially just `git reset --hard`, which xit already has in the form of `xit reset-dir`, but it wasn't correctly cleaning up the merge state. Now it is, and you can --abort all you want.</p>
  <p>The next day I turned to `push`, because there was an issue that I doubt people would enjoy: all pushes were force pushes. This is because the server does not check if you're about to obliterate any commits...that check is done client-side by git! I <a href="https://github.com/radarroark/xit/commit/c9a5ebac3e81031ae536a41b567de6fbecb5d2b9">added</a> the check to xit, along with a -f flag to bypass it.</p>
  <p>I had to get away from networking for a while so the next day I turned to the TUI. I added an obvious optimization that I should've added long ago: <a href="https://github.com/radarroark/xitui/commit/ac9e7f2dc65be4bc0b6e83d3f73bd609261db6bf">buffered</a> writing. The TUI on windows was particularly slow but now it's actually usable. I also made the TUI exit cleanly when <a href="https://github.com/radarroark/xitui/commit/3a5030476cf7e745357a26d9f541bb5c47b07d3c">ctrl+c</a> is entered.</p>
  <p>And that brings me to yesterday, when I added support for <a href="https://github.com/radarroark/xit/commit/43035cf7a1e44d12f8f893fa42ab2fab30232a0e">symlinks</a>. That was WAY more annoying than I thought it would be. Fuck symlinks. Apparently windows agrees, because it doesn't even let you make them without admin privileges...so xit is forced to just make a normal file, just like git does. Speaking of windows, I also added a nice <a href="https://github.com/radarroark/xit/commit/26febda417fdac186984ba47aa4c09891397a7a6">fix</a> to prevent windows users from accidentally overwriting the file mode in a repo.</p>
  <p>That was just one week of work! Oh...and this blog is no longer wrapping every single character in span tags. That really triggered a lot of web developers. This is what happens when you put a Zig programmer in charge of HTML. I hope you all learned a valuable lesson.</p>
  ]]></content>
 </entry>

 <entry>
  <title>xit is coming</title>
  <link href="https://radarroark.github.io/xit/xit-is-coming.html" title="xit-is-coming"/>
  <id>urn:uuid:67d94c95-dff4-468b-9c8d-c13d1a12dc04</id>
  <updated>2025-03-04T00:00:00Z</updated>
  <content type="html" xml:lang="en"><![CDATA[
  <p>I'm working on a new version control system called <a href="https://github.com/radarroark/xit">xit</a> (pronounced like "zit"). To paraphrase JFK: I do this not because it is easy...but because I thought it would be easy. It is hilarious how much I misjudged how hard this would be. Nonetheless, here are the main features:</p>
  <p>1. Compatible with git hosts. You can push/pull/clone with Github and other git hosts, and nobody will even know you're using xit. I spent all of this past winter implementing the git protocol, and contrary to popular belief I am not perfect, so PLEASE REPORT BUGS!</p>
  <p>2. Combine snapshot-based and patch-based version control. When you merge or cherry-pick with xit, it uses patch-based merging, which should be more reliable and lead to fewer merge conflicts than git's three-way merge. Once again, until it sees more real-world use you should temper expectations.</p>
  <p>3. Built-in text user interface (TUI). If you just launch `xit` in a repo with no extra arguments, it will launch a TUI where you can browse commits and view the status of all uncommitted changes. Eventually the TUI will expose *all* the functionality of xit, including making commits and performing merges, but I'm not quite there yet.</p>
  <p>4. Store large/binary files efficiently. Internally, xit stores objects in a completely different way than git does. It uses FastCDC to break up files into chunks, somewhat like BitTorrent except the chunks are variable sized. The goal is to be excellent at storing large, binary files, so we never need an add-on like git LFS.</p>
  <p>5. Universal undo. Any change to the repo will be undoable. Yes, I mean *any* change. That includes not just changes to refs (as shown in git's reflog) but also changes to the index, the config, and so on. I'm still working on this feature so it's not available yet. It should land soon, but for now, it's vaporware.</p>
  <p>Git's 20th birthday is in April 2025. So much has changed in those two decades, and we need a tool that is free from the design limitations and technical debt that has accrued in git. If all goes well, xit will celebrate its 20th birthday in 2045 as an old incumbent being challenged by a newcomer.</p>
  <p>If that day comes, I'll do my best to sabotage the newcomer's attempt to unseat me from the throne...just kidding, of course. I'll nod sagely in my bathrobe with a beverage in hand and continue not caring.</p>
  ]]></content>
 </entry>

</feed>
