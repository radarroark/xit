<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>xitlog</title>
 <link href="https://radarroark.github.io/xit"/>
 <updated>2025-03-13T00:00:00Z</updated>
 <author>
   <name>radar roark</name>
 </author>
 <id>https://radarroark.github.io/xit</id>

 <entry>
  <title>devlog - optional patches, force push, symlinks and more</title>
  <link href="https://radarroark.github.io/xit/devlog-optional-patches.html" title="devlog-optional-patches"/>
  <id>urn:uuid:7aa7555a-0163-4590-b0f6-4da325dbd692</id>
  <updated>2025-03-13T00:00:00Z</updated>
  <content type="html" xml:lang="en"><![CDATA[
  <p>I got my first couple bug reports...mama, we made it! In <a href="https://github.com/radarroark/xit/issues/2">#2</a> I forgot that in <a href="https://github.com/radarroark/xitdb">xitdb</a>, data made in a transaction is temporarily mutable (an important perf optimization). It's fun forgetting how my own database works. In <a href="https://github.com/radarroark/xit/issues/4">#4</a> I forgot that when you merge, the base commit might not actually contain the conflicting file. Oops.</p>
  <p>Shortly after that, I made patch-based merging <a href="https://github.com/radarroark/xit/commit/cfd04126c30a76c93d60b2c94e976fec81cae36e">optional</a>. It no longer generates patches during the clone, so cloning repos with large histories won't outlast the heat death of the universe. It still takes more time than git, because it is decompressing and chunking each object...I'm working on making it faster.</p>
  <p>The next morning I woke up feeling particularly masochistic, so I decided to work on the pack file code. I noticed that some fetches were failing because the pack file from the server contained a <a href="https://git-scm.com/docs/pack-format">REF_DELTA</a> object, which is an deltified object whose base object is not in the pack and is expected to already be in the object store. I <a href="https://github.com/radarroark/xit/commit/940452a07f9dc7f299d200a3f5f6de29fa3b3738">fixed</a> the pack object reader to read these objects correctly, and then told my therapist all about it later that day.</p>
  <p>After recovering from that eldritch horror I implemented <a href="https://github.com/radarroark/xit/commit/cc3467ca99118867462314b4ee940f99ac6bac8c">--abort</a> for merge and cherry-pick. This would normally be easy because it's essentially just `git reset --hard`, which xit already has in the form of `xit reset-dir`, but it wasn't correctly cleaning up the merge state. Now it is, and you can --abort all you want.</p>
  <p>The next day I turned to `push`, because there was an issue that I doubt people would enjoy: all pushes were force pushes. This is because the server does not check if you're about to obliterate any commits...that check is done client-side by git! I <a href="https://github.com/radarroark/xit/commit/c9a5ebac3e81031ae536a41b567de6fbecb5d2b9">added</a> the check to xit, along with a -f flag to bypass it.</p>
  <p>I had to get away from networking for a while so the next day I turned to the TUI. I added an obvious optimization that I should've added long ago: <a href="https://github.com/radarroark/xitui/commit/ac9e7f2dc65be4bc0b6e83d3f73bd609261db6bf">buffered</a> writing. The TUI on windows was particularly slow but now it's actually usable. I also made the TUI exit cleanly when <a href="https://github.com/radarroark/xitui/commit/3a5030476cf7e745357a26d9f541bb5c47b07d3c">ctrl+c</a> is entered.</p>
  <p>And that brings me to yesterday, when I added support for <a href="https://github.com/radarroark/xit/commit/43035cf7a1e44d12f8f893fa42ab2fab30232a0e">symlinks</a>. That was WAY more annoying than I thought it would be. Fuck symlinks. Apparently windows agrees, because it doesn't even let you make them without admin privileges...so xit is forced to just make a normal file, just like git does. Speaking of windows, I also added a nice <a href="https://github.com/radarroark/xit/commit/26febda417fdac186984ba47aa4c09891397a7a6">fix</a> to prevent windows users from accidentally overwriting the file mode in a repo.</p>
  <p>That was just one week of work! Oh...and this blog is no longer wrapping every single character in span tags. That really triggered a lot of web developers. This is what happens when you put a Zig programmer in charge of HTML. I hope you all learned a valuable lesson.</p>
  ]]></content>
 </entry>

 <entry>
  <title>xit is coming</title>
  <link href="https://radarroark.github.io/xit/xit-is-coming.html" title="xit-is-coming"/>
  <id>urn:uuid:67d94c95-dff4-468b-9c8d-c13d1a12dc04</id>
  <updated>2025-03-04T00:00:00Z</updated>
  <content type="html" xml:lang="en"><![CDATA[
  <p>I'm working on a new version control system called <a href="https://github.com/radarroark/xit">xit</a> (pronounced like "zit"). To paraphrase JFK: I do this not because it is easy...but because I thought it would be easy. It is hilarious how much I misjudged how hard this would be. Nonetheless, here are the main features:</p>
  <p>1. Compatible with git hosts. You can push/pull/clone with Github and other git hosts, and nobody will even know you're using xit. I spent all of this past winter implementing the git protocol, and contrary to popular belief I am not perfect, so PLEASE REPORT BUGS!</p>
  <p>2. Combine snapshot-based and patch-based version control. When you merge or cherry-pick with xit, it uses patch-based merging, which should be more reliable and lead to fewer merge conflicts than git's three-way merge. Once again, until it sees more real-world use you should temper expectations.</p>
  <p>3. Built-in text user interface (TUI). If you just launch `xit` in a repo with no extra arguments, it will launch a TUI where you can browse commits and view the status of all uncommitted changes. Eventually the TUI will expose *all* the functionality of xit, including making commits and performing merges, but I'm not quite there yet.</p>
  <p>4. Store large/binary files efficiently. Internally, xit stores objects in a completely different way than git does. It uses FastCDC to break up files into chunks, somewhat like BitTorrent except the chunks are variable sized. The goal is to be excellent at storing large, binary files, so we never need an add-on like git LFS.</p>
  <p>5. Universal undo. Any change to the repo will be undoable. Yes, I mean *any* change. That includes not just changes to refs (as shown in git's reflog) but also changes to the index, the config, and so on. I'm still working on this feature so it's not available yet. It should land soon, but for now, it's vaporware.</p>
  <p>Git's 20th birthday is in April 2025. So much has changed in those two decades, and we need a tool that is free from the design limitations and technical debt that has accrued in git. If all goes well, xit will celebrate its 20th birthday in 2045 as an old incumbent being challenged by a newcomer.</p>
  <p>If that day comes, I'll do my best to sabotage the newcomer's attempt to unseat me from the throne...just kidding, of course. I'll nod sagely in my bathrobe with a beverage in hand and continue not caring.</p>
  ]]></content>
 </entry>

</feed>
